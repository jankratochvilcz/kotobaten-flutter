// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'practice_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$PracticeModel {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(
            List<Impression> allImpressions, bool? navigatedAway)
        finished,
    required TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)
        inProgress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult? Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PracticeModelInitial value) initial,
    required TResult Function(PracticeModelLoading value) loading,
    required TResult Function(PracticeModelError value) error,
    required TResult Function(PracticeModelFinished value) finished,
    required TResult Function(PracticeModelInProgress value) inProgress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PracticeModelInitial value)? initial,
    TResult? Function(PracticeModelLoading value)? loading,
    TResult? Function(PracticeModelError value)? error,
    TResult? Function(PracticeModelFinished value)? finished,
    TResult? Function(PracticeModelInProgress value)? inProgress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PracticeModelInitial value)? initial,
    TResult Function(PracticeModelLoading value)? loading,
    TResult Function(PracticeModelError value)? error,
    TResult Function(PracticeModelFinished value)? finished,
    TResult Function(PracticeModelInProgress value)? inProgress,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PracticeModelCopyWith<$Res> {
  factory $PracticeModelCopyWith(
          PracticeModel value, $Res Function(PracticeModel) then) =
      _$PracticeModelCopyWithImpl<$Res, PracticeModel>;
}

/// @nodoc
class _$PracticeModelCopyWithImpl<$Res, $Val extends PracticeModel>
    implements $PracticeModelCopyWith<$Res> {
  _$PracticeModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PracticeModelInitialImplCopyWith<$Res> {
  factory _$$PracticeModelInitialImplCopyWith(_$PracticeModelInitialImpl value,
          $Res Function(_$PracticeModelInitialImpl) then) =
      __$$PracticeModelInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PracticeModelInitialImplCopyWithImpl<$Res>
    extends _$PracticeModelCopyWithImpl<$Res, _$PracticeModelInitialImpl>
    implements _$$PracticeModelInitialImplCopyWith<$Res> {
  __$$PracticeModelInitialImplCopyWithImpl(_$PracticeModelInitialImpl _value,
      $Res Function(_$PracticeModelInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PracticeModelInitialImpl extends PracticeModelInitial {
  const _$PracticeModelInitialImpl() : super._();

  @override
  String toString() {
    return 'PracticeModel.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PracticeModelInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(
            List<Impression> allImpressions, bool? navigatedAway)
        finished,
    required TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)
        inProgress,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult? Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PracticeModelInitial value) initial,
    required TResult Function(PracticeModelLoading value) loading,
    required TResult Function(PracticeModelError value) error,
    required TResult Function(PracticeModelFinished value) finished,
    required TResult Function(PracticeModelInProgress value) inProgress,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PracticeModelInitial value)? initial,
    TResult? Function(PracticeModelLoading value)? loading,
    TResult? Function(PracticeModelError value)? error,
    TResult? Function(PracticeModelFinished value)? finished,
    TResult? Function(PracticeModelInProgress value)? inProgress,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PracticeModelInitial value)? initial,
    TResult Function(PracticeModelLoading value)? loading,
    TResult Function(PracticeModelError value)? error,
    TResult Function(PracticeModelFinished value)? finished,
    TResult Function(PracticeModelInProgress value)? inProgress,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class PracticeModelInitial extends PracticeModel {
  const factory PracticeModelInitial() = _$PracticeModelInitialImpl;
  const PracticeModelInitial._() : super._();
}

/// @nodoc
abstract class _$$PracticeModelLoadingImplCopyWith<$Res> {
  factory _$$PracticeModelLoadingImplCopyWith(_$PracticeModelLoadingImpl value,
          $Res Function(_$PracticeModelLoadingImpl) then) =
      __$$PracticeModelLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PracticeModelLoadingImplCopyWithImpl<$Res>
    extends _$PracticeModelCopyWithImpl<$Res, _$PracticeModelLoadingImpl>
    implements _$$PracticeModelLoadingImplCopyWith<$Res> {
  __$$PracticeModelLoadingImplCopyWithImpl(_$PracticeModelLoadingImpl _value,
      $Res Function(_$PracticeModelLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PracticeModelLoadingImpl extends PracticeModelLoading {
  const _$PracticeModelLoadingImpl() : super._();

  @override
  String toString() {
    return 'PracticeModel.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PracticeModelLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(
            List<Impression> allImpressions, bool? navigatedAway)
        finished,
    required TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)
        inProgress,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult? Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PracticeModelInitial value) initial,
    required TResult Function(PracticeModelLoading value) loading,
    required TResult Function(PracticeModelError value) error,
    required TResult Function(PracticeModelFinished value) finished,
    required TResult Function(PracticeModelInProgress value) inProgress,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PracticeModelInitial value)? initial,
    TResult? Function(PracticeModelLoading value)? loading,
    TResult? Function(PracticeModelError value)? error,
    TResult? Function(PracticeModelFinished value)? finished,
    TResult? Function(PracticeModelInProgress value)? inProgress,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PracticeModelInitial value)? initial,
    TResult Function(PracticeModelLoading value)? loading,
    TResult Function(PracticeModelError value)? error,
    TResult Function(PracticeModelFinished value)? finished,
    TResult Function(PracticeModelInProgress value)? inProgress,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class PracticeModelLoading extends PracticeModel {
  const factory PracticeModelLoading() = _$PracticeModelLoadingImpl;
  const PracticeModelLoading._() : super._();
}

/// @nodoc
abstract class _$$PracticeModelErrorImplCopyWith<$Res> {
  factory _$$PracticeModelErrorImplCopyWith(_$PracticeModelErrorImpl value,
          $Res Function(_$PracticeModelErrorImpl) then) =
      __$$PracticeModelErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$PracticeModelErrorImplCopyWithImpl<$Res>
    extends _$PracticeModelCopyWithImpl<$Res, _$PracticeModelErrorImpl>
    implements _$$PracticeModelErrorImplCopyWith<$Res> {
  __$$PracticeModelErrorImplCopyWithImpl(_$PracticeModelErrorImpl _value,
      $Res Function(_$PracticeModelErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$PracticeModelErrorImpl(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PracticeModelErrorImpl extends PracticeModelError {
  const _$PracticeModelErrorImpl(this.error) : super._();

  @override
  final String error;

  @override
  String toString() {
    return 'PracticeModel.error(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PracticeModelErrorImpl &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PracticeModelErrorImplCopyWith<_$PracticeModelErrorImpl> get copyWith =>
      __$$PracticeModelErrorImplCopyWithImpl<_$PracticeModelErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(
            List<Impression> allImpressions, bool? navigatedAway)
        finished,
    required TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)
        inProgress,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult? Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PracticeModelInitial value) initial,
    required TResult Function(PracticeModelLoading value) loading,
    required TResult Function(PracticeModelError value) error,
    required TResult Function(PracticeModelFinished value) finished,
    required TResult Function(PracticeModelInProgress value) inProgress,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PracticeModelInitial value)? initial,
    TResult? Function(PracticeModelLoading value)? loading,
    TResult? Function(PracticeModelError value)? error,
    TResult? Function(PracticeModelFinished value)? finished,
    TResult? Function(PracticeModelInProgress value)? inProgress,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PracticeModelInitial value)? initial,
    TResult Function(PracticeModelLoading value)? loading,
    TResult Function(PracticeModelError value)? error,
    TResult Function(PracticeModelFinished value)? finished,
    TResult Function(PracticeModelInProgress value)? inProgress,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class PracticeModelError extends PracticeModel {
  const factory PracticeModelError(final String error) =
      _$PracticeModelErrorImpl;
  const PracticeModelError._() : super._();

  String get error;
  @JsonKey(ignore: true)
  _$$PracticeModelErrorImplCopyWith<_$PracticeModelErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PracticeModelFinishedImplCopyWith<$Res> {
  factory _$$PracticeModelFinishedImplCopyWith(
          _$PracticeModelFinishedImpl value,
          $Res Function(_$PracticeModelFinishedImpl) then) =
      __$$PracticeModelFinishedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Impression> allImpressions, bool? navigatedAway});
}

/// @nodoc
class __$$PracticeModelFinishedImplCopyWithImpl<$Res>
    extends _$PracticeModelCopyWithImpl<$Res, _$PracticeModelFinishedImpl>
    implements _$$PracticeModelFinishedImplCopyWith<$Res> {
  __$$PracticeModelFinishedImplCopyWithImpl(_$PracticeModelFinishedImpl _value,
      $Res Function(_$PracticeModelFinishedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? allImpressions = null,
    Object? navigatedAway = freezed,
  }) {
    return _then(_$PracticeModelFinishedImpl(
      null == allImpressions
          ? _value._allImpressions
          : allImpressions // ignore: cast_nullable_to_non_nullable
              as List<Impression>,
      navigatedAway: freezed == navigatedAway
          ? _value.navigatedAway
          : navigatedAway // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc

class _$PracticeModelFinishedImpl extends PracticeModelFinished {
  const _$PracticeModelFinishedImpl(final List<Impression> allImpressions,
      {this.navigatedAway})
      : _allImpressions = allImpressions,
        super._();

  final List<Impression> _allImpressions;
  @override
  List<Impression> get allImpressions {
    if (_allImpressions is EqualUnmodifiableListView) return _allImpressions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_allImpressions);
  }

  @override
  final bool? navigatedAway;

  @override
  String toString() {
    return 'PracticeModel.finished(allImpressions: $allImpressions, navigatedAway: $navigatedAway)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PracticeModelFinishedImpl &&
            const DeepCollectionEquality()
                .equals(other._allImpressions, _allImpressions) &&
            (identical(other.navigatedAway, navigatedAway) ||
                other.navigatedAway == navigatedAway));
  }

  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_allImpressions), navigatedAway);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PracticeModelFinishedImplCopyWith<_$PracticeModelFinishedImpl>
      get copyWith => __$$PracticeModelFinishedImplCopyWithImpl<
          _$PracticeModelFinishedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(
            List<Impression> allImpressions, bool? navigatedAway)
        finished,
    required TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)
        inProgress,
  }) {
    return finished(allImpressions, navigatedAway);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult? Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
  }) {
    return finished?.call(allImpressions, navigatedAway);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
    required TResult orElse(),
  }) {
    if (finished != null) {
      return finished(allImpressions, navigatedAway);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PracticeModelInitial value) initial,
    required TResult Function(PracticeModelLoading value) loading,
    required TResult Function(PracticeModelError value) error,
    required TResult Function(PracticeModelFinished value) finished,
    required TResult Function(PracticeModelInProgress value) inProgress,
  }) {
    return finished(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PracticeModelInitial value)? initial,
    TResult? Function(PracticeModelLoading value)? loading,
    TResult? Function(PracticeModelError value)? error,
    TResult? Function(PracticeModelFinished value)? finished,
    TResult? Function(PracticeModelInProgress value)? inProgress,
  }) {
    return finished?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PracticeModelInitial value)? initial,
    TResult Function(PracticeModelLoading value)? loading,
    TResult Function(PracticeModelError value)? error,
    TResult Function(PracticeModelFinished value)? finished,
    TResult Function(PracticeModelInProgress value)? inProgress,
    required TResult orElse(),
  }) {
    if (finished != null) {
      return finished(this);
    }
    return orElse();
  }
}

abstract class PracticeModelFinished extends PracticeModel {
  const factory PracticeModelFinished(final List<Impression> allImpressions,
      {final bool? navigatedAway}) = _$PracticeModelFinishedImpl;
  const PracticeModelFinished._() : super._();

  List<Impression> get allImpressions;
  bool? get navigatedAway;
  @JsonKey(ignore: true)
  _$$PracticeModelFinishedImplCopyWith<_$PracticeModelFinishedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PracticeModelInProgressImplCopyWith<$Res> {
  factory _$$PracticeModelInProgressImplCopyWith(
          _$PracticeModelInProgressImpl value,
          $Res Function(_$PracticeModelInProgressImpl) then) =
      __$$PracticeModelInProgressImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {List<Impression> allImpressions,
      List<Impression> remainingImpressions,
      Impression currentImpression,
      bool revealed,
      bool speechPlayed,
      DateTime? nextStepTime,
      DateTime? currentStepStart,
      double? pausedPercentage});
}

/// @nodoc
class __$$PracticeModelInProgressImplCopyWithImpl<$Res>
    extends _$PracticeModelCopyWithImpl<$Res, _$PracticeModelInProgressImpl>
    implements _$$PracticeModelInProgressImplCopyWith<$Res> {
  __$$PracticeModelInProgressImplCopyWithImpl(
      _$PracticeModelInProgressImpl _value,
      $Res Function(_$PracticeModelInProgressImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? allImpressions = null,
    Object? remainingImpressions = null,
    Object? currentImpression = null,
    Object? revealed = null,
    Object? speechPlayed = null,
    Object? nextStepTime = freezed,
    Object? currentStepStart = freezed,
    Object? pausedPercentage = freezed,
  }) {
    return _then(_$PracticeModelInProgressImpl(
      null == allImpressions
          ? _value._allImpressions
          : allImpressions // ignore: cast_nullable_to_non_nullable
              as List<Impression>,
      null == remainingImpressions
          ? _value._remainingImpressions
          : remainingImpressions // ignore: cast_nullable_to_non_nullable
              as List<Impression>,
      null == currentImpression
          ? _value.currentImpression
          : currentImpression // ignore: cast_nullable_to_non_nullable
              as Impression,
      null == revealed
          ? _value.revealed
          : revealed // ignore: cast_nullable_to_non_nullable
              as bool,
      null == speechPlayed
          ? _value.speechPlayed
          : speechPlayed // ignore: cast_nullable_to_non_nullable
              as bool,
      nextStepTime: freezed == nextStepTime
          ? _value.nextStepTime
          : nextStepTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      currentStepStart: freezed == currentStepStart
          ? _value.currentStepStart
          : currentStepStart // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      pausedPercentage: freezed == pausedPercentage
          ? _value.pausedPercentage
          : pausedPercentage // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc

class _$PracticeModelInProgressImpl extends PracticeModelInProgress {
  const _$PracticeModelInProgressImpl(
      final List<Impression> allImpressions,
      final List<Impression> remainingImpressions,
      this.currentImpression,
      this.revealed,
      this.speechPlayed,
      {this.nextStepTime,
      this.currentStepStart,
      this.pausedPercentage})
      : _allImpressions = allImpressions,
        _remainingImpressions = remainingImpressions,
        super._();

  final List<Impression> _allImpressions;
  @override
  List<Impression> get allImpressions {
    if (_allImpressions is EqualUnmodifiableListView) return _allImpressions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_allImpressions);
  }

  final List<Impression> _remainingImpressions;
  @override
  List<Impression> get remainingImpressions {
    if (_remainingImpressions is EqualUnmodifiableListView)
      return _remainingImpressions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_remainingImpressions);
  }

  @override
  final Impression currentImpression;
  @override
  final bool revealed;
  @override
  final bool speechPlayed;
  @override
  final DateTime? nextStepTime;
  @override
  final DateTime? currentStepStart;
  @override
  final double? pausedPercentage;

  @override
  String toString() {
    return 'PracticeModel.inProgress(allImpressions: $allImpressions, remainingImpressions: $remainingImpressions, currentImpression: $currentImpression, revealed: $revealed, speechPlayed: $speechPlayed, nextStepTime: $nextStepTime, currentStepStart: $currentStepStart, pausedPercentage: $pausedPercentage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PracticeModelInProgressImpl &&
            const DeepCollectionEquality()
                .equals(other._allImpressions, _allImpressions) &&
            const DeepCollectionEquality()
                .equals(other._remainingImpressions, _remainingImpressions) &&
            (identical(other.currentImpression, currentImpression) ||
                other.currentImpression == currentImpression) &&
            (identical(other.revealed, revealed) ||
                other.revealed == revealed) &&
            (identical(other.speechPlayed, speechPlayed) ||
                other.speechPlayed == speechPlayed) &&
            (identical(other.nextStepTime, nextStepTime) ||
                other.nextStepTime == nextStepTime) &&
            (identical(other.currentStepStart, currentStepStart) ||
                other.currentStepStart == currentStepStart) &&
            (identical(other.pausedPercentage, pausedPercentage) ||
                other.pausedPercentage == pausedPercentage));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_allImpressions),
      const DeepCollectionEquality().hash(_remainingImpressions),
      currentImpression,
      revealed,
      speechPlayed,
      nextStepTime,
      currentStepStart,
      pausedPercentage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PracticeModelInProgressImplCopyWith<_$PracticeModelInProgressImpl>
      get copyWith => __$$PracticeModelInProgressImplCopyWithImpl<
          _$PracticeModelInProgressImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(
            List<Impression> allImpressions, bool? navigatedAway)
        finished,
    required TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)
        inProgress,
  }) {
    return inProgress(
        allImpressions,
        remainingImpressions,
        currentImpression,
        revealed,
        speechPlayed,
        nextStepTime,
        currentStepStart,
        pausedPercentage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult? Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
  }) {
    return inProgress?.call(
        allImpressions,
        remainingImpressions,
        currentImpression,
        revealed,
        speechPlayed,
        nextStepTime,
        currentStepStart,
        pausedPercentage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
    required TResult orElse(),
  }) {
    if (inProgress != null) {
      return inProgress(
          allImpressions,
          remainingImpressions,
          currentImpression,
          revealed,
          speechPlayed,
          nextStepTime,
          currentStepStart,
          pausedPercentage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PracticeModelInitial value) initial,
    required TResult Function(PracticeModelLoading value) loading,
    required TResult Function(PracticeModelError value) error,
    required TResult Function(PracticeModelFinished value) finished,
    required TResult Function(PracticeModelInProgress value) inProgress,
  }) {
    return inProgress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PracticeModelInitial value)? initial,
    TResult? Function(PracticeModelLoading value)? loading,
    TResult? Function(PracticeModelError value)? error,
    TResult? Function(PracticeModelFinished value)? finished,
    TResult? Function(PracticeModelInProgress value)? inProgress,
  }) {
    return inProgress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PracticeModelInitial value)? initial,
    TResult Function(PracticeModelLoading value)? loading,
    TResult Function(PracticeModelError value)? error,
    TResult Function(PracticeModelFinished value)? finished,
    TResult Function(PracticeModelInProgress value)? inProgress,
    required TResult orElse(),
  }) {
    if (inProgress != null) {
      return inProgress(this);
    }
    return orElse();
  }
}

abstract class PracticeModelInProgress extends PracticeModel {
  const factory PracticeModelInProgress(
      final List<Impression> allImpressions,
      final List<Impression> remainingImpressions,
      final Impression currentImpression,
      final bool revealed,
      final bool speechPlayed,
      {final DateTime? nextStepTime,
      final DateTime? currentStepStart,
      final double? pausedPercentage}) = _$PracticeModelInProgressImpl;
  const PracticeModelInProgress._() : super._();

  List<Impression> get allImpressions;
  List<Impression> get remainingImpressions;
  Impression get currentImpression;
  bool get revealed;
  bool get speechPlayed;
  DateTime? get nextStepTime;
  DateTime? get currentStepStart;
  double? get pausedPercentage;
  @JsonKey(ignore: true)
  _$$PracticeModelInProgressImplCopyWith<_$PracticeModelInProgressImpl>
      get copyWith => throw _privateConstructorUsedError;
}
