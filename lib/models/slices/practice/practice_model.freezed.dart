// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'practice_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$PracticeModel {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(
            List<Impression> allImpressions, bool? navigatedAway)
        finished,
    required TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)
        inProgress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult? Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PracticeModelInitial value) initial,
    required TResult Function(PracticeModelLoading value) loading,
    required TResult Function(PracticeModelError value) error,
    required TResult Function(PracticeModelFinished value) finished,
    required TResult Function(PracticeModelInProgress value) inProgress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PracticeModelInitial value)? initial,
    TResult? Function(PracticeModelLoading value)? loading,
    TResult? Function(PracticeModelError value)? error,
    TResult? Function(PracticeModelFinished value)? finished,
    TResult? Function(PracticeModelInProgress value)? inProgress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PracticeModelInitial value)? initial,
    TResult Function(PracticeModelLoading value)? loading,
    TResult Function(PracticeModelError value)? error,
    TResult Function(PracticeModelFinished value)? finished,
    TResult Function(PracticeModelInProgress value)? inProgress,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PracticeModelCopyWith<$Res> {
  factory $PracticeModelCopyWith(
          PracticeModel value, $Res Function(PracticeModel) then) =
      _$PracticeModelCopyWithImpl<$Res, PracticeModel>;
}

/// @nodoc
class _$PracticeModelCopyWithImpl<$Res, $Val extends PracticeModel>
    implements $PracticeModelCopyWith<$Res> {
  _$PracticeModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PracticeModelInitialCopyWith<$Res> {
  factory _$$PracticeModelInitialCopyWith(_$PracticeModelInitial value,
          $Res Function(_$PracticeModelInitial) then) =
      __$$PracticeModelInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PracticeModelInitialCopyWithImpl<$Res>
    extends _$PracticeModelCopyWithImpl<$Res, _$PracticeModelInitial>
    implements _$$PracticeModelInitialCopyWith<$Res> {
  __$$PracticeModelInitialCopyWithImpl(_$PracticeModelInitial _value,
      $Res Function(_$PracticeModelInitial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PracticeModelInitial extends PracticeModelInitial {
  const _$PracticeModelInitial() : super._();

  @override
  String toString() {
    return 'PracticeModel.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PracticeModelInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(
            List<Impression> allImpressions, bool? navigatedAway)
        finished,
    required TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)
        inProgress,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult? Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PracticeModelInitial value) initial,
    required TResult Function(PracticeModelLoading value) loading,
    required TResult Function(PracticeModelError value) error,
    required TResult Function(PracticeModelFinished value) finished,
    required TResult Function(PracticeModelInProgress value) inProgress,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PracticeModelInitial value)? initial,
    TResult? Function(PracticeModelLoading value)? loading,
    TResult? Function(PracticeModelError value)? error,
    TResult? Function(PracticeModelFinished value)? finished,
    TResult? Function(PracticeModelInProgress value)? inProgress,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PracticeModelInitial value)? initial,
    TResult Function(PracticeModelLoading value)? loading,
    TResult Function(PracticeModelError value)? error,
    TResult Function(PracticeModelFinished value)? finished,
    TResult Function(PracticeModelInProgress value)? inProgress,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class PracticeModelInitial extends PracticeModel {
  const factory PracticeModelInitial() = _$PracticeModelInitial;
  const PracticeModelInitial._() : super._();
}

/// @nodoc
abstract class _$$PracticeModelLoadingCopyWith<$Res> {
  factory _$$PracticeModelLoadingCopyWith(_$PracticeModelLoading value,
          $Res Function(_$PracticeModelLoading) then) =
      __$$PracticeModelLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PracticeModelLoadingCopyWithImpl<$Res>
    extends _$PracticeModelCopyWithImpl<$Res, _$PracticeModelLoading>
    implements _$$PracticeModelLoadingCopyWith<$Res> {
  __$$PracticeModelLoadingCopyWithImpl(_$PracticeModelLoading _value,
      $Res Function(_$PracticeModelLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PracticeModelLoading extends PracticeModelLoading {
  const _$PracticeModelLoading() : super._();

  @override
  String toString() {
    return 'PracticeModel.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PracticeModelLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(
            List<Impression> allImpressions, bool? navigatedAway)
        finished,
    required TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)
        inProgress,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult? Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PracticeModelInitial value) initial,
    required TResult Function(PracticeModelLoading value) loading,
    required TResult Function(PracticeModelError value) error,
    required TResult Function(PracticeModelFinished value) finished,
    required TResult Function(PracticeModelInProgress value) inProgress,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PracticeModelInitial value)? initial,
    TResult? Function(PracticeModelLoading value)? loading,
    TResult? Function(PracticeModelError value)? error,
    TResult? Function(PracticeModelFinished value)? finished,
    TResult? Function(PracticeModelInProgress value)? inProgress,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PracticeModelInitial value)? initial,
    TResult Function(PracticeModelLoading value)? loading,
    TResult Function(PracticeModelError value)? error,
    TResult Function(PracticeModelFinished value)? finished,
    TResult Function(PracticeModelInProgress value)? inProgress,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class PracticeModelLoading extends PracticeModel {
  const factory PracticeModelLoading() = _$PracticeModelLoading;
  const PracticeModelLoading._() : super._();
}

/// @nodoc
abstract class _$$PracticeModelErrorCopyWith<$Res> {
  factory _$$PracticeModelErrorCopyWith(_$PracticeModelError value,
          $Res Function(_$PracticeModelError) then) =
      __$$PracticeModelErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$PracticeModelErrorCopyWithImpl<$Res>
    extends _$PracticeModelCopyWithImpl<$Res, _$PracticeModelError>
    implements _$$PracticeModelErrorCopyWith<$Res> {
  __$$PracticeModelErrorCopyWithImpl(
      _$PracticeModelError _value, $Res Function(_$PracticeModelError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$PracticeModelError(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PracticeModelError extends PracticeModelError {
  const _$PracticeModelError(this.error) : super._();

  @override
  final String error;

  @override
  String toString() {
    return 'PracticeModel.error(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PracticeModelError &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PracticeModelErrorCopyWith<_$PracticeModelError> get copyWith =>
      __$$PracticeModelErrorCopyWithImpl<_$PracticeModelError>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(
            List<Impression> allImpressions, bool? navigatedAway)
        finished,
    required TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)
        inProgress,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult? Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PracticeModelInitial value) initial,
    required TResult Function(PracticeModelLoading value) loading,
    required TResult Function(PracticeModelError value) error,
    required TResult Function(PracticeModelFinished value) finished,
    required TResult Function(PracticeModelInProgress value) inProgress,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PracticeModelInitial value)? initial,
    TResult? Function(PracticeModelLoading value)? loading,
    TResult? Function(PracticeModelError value)? error,
    TResult? Function(PracticeModelFinished value)? finished,
    TResult? Function(PracticeModelInProgress value)? inProgress,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PracticeModelInitial value)? initial,
    TResult Function(PracticeModelLoading value)? loading,
    TResult Function(PracticeModelError value)? error,
    TResult Function(PracticeModelFinished value)? finished,
    TResult Function(PracticeModelInProgress value)? inProgress,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class PracticeModelError extends PracticeModel {
  const factory PracticeModelError(final String error) = _$PracticeModelError;
  const PracticeModelError._() : super._();

  String get error;
  @JsonKey(ignore: true)
  _$$PracticeModelErrorCopyWith<_$PracticeModelError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PracticeModelFinishedCopyWith<$Res> {
  factory _$$PracticeModelFinishedCopyWith(_$PracticeModelFinished value,
          $Res Function(_$PracticeModelFinished) then) =
      __$$PracticeModelFinishedCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Impression> allImpressions, bool? navigatedAway});
}

/// @nodoc
class __$$PracticeModelFinishedCopyWithImpl<$Res>
    extends _$PracticeModelCopyWithImpl<$Res, _$PracticeModelFinished>
    implements _$$PracticeModelFinishedCopyWith<$Res> {
  __$$PracticeModelFinishedCopyWithImpl(_$PracticeModelFinished _value,
      $Res Function(_$PracticeModelFinished) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? allImpressions = null,
    Object? navigatedAway = freezed,
  }) {
    return _then(_$PracticeModelFinished(
      null == allImpressions
          ? _value._allImpressions
          : allImpressions // ignore: cast_nullable_to_non_nullable
              as List<Impression>,
      navigatedAway: freezed == navigatedAway
          ? _value.navigatedAway
          : navigatedAway // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc

class _$PracticeModelFinished extends PracticeModelFinished {
  const _$PracticeModelFinished(final List<Impression> allImpressions,
      {this.navigatedAway})
      : _allImpressions = allImpressions,
        super._();

  final List<Impression> _allImpressions;
  @override
  List<Impression> get allImpressions {
    if (_allImpressions is EqualUnmodifiableListView) return _allImpressions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_allImpressions);
  }

  @override
  final bool? navigatedAway;

  @override
  String toString() {
    return 'PracticeModel.finished(allImpressions: $allImpressions, navigatedAway: $navigatedAway)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PracticeModelFinished &&
            const DeepCollectionEquality()
                .equals(other._allImpressions, _allImpressions) &&
            (identical(other.navigatedAway, navigatedAway) ||
                other.navigatedAway == navigatedAway));
  }

  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_allImpressions), navigatedAway);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PracticeModelFinishedCopyWith<_$PracticeModelFinished> get copyWith =>
      __$$PracticeModelFinishedCopyWithImpl<_$PracticeModelFinished>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(
            List<Impression> allImpressions, bool? navigatedAway)
        finished,
    required TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)
        inProgress,
  }) {
    return finished(allImpressions, navigatedAway);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult? Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
  }) {
    return finished?.call(allImpressions, navigatedAway);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
    required TResult orElse(),
  }) {
    if (finished != null) {
      return finished(allImpressions, navigatedAway);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PracticeModelInitial value) initial,
    required TResult Function(PracticeModelLoading value) loading,
    required TResult Function(PracticeModelError value) error,
    required TResult Function(PracticeModelFinished value) finished,
    required TResult Function(PracticeModelInProgress value) inProgress,
  }) {
    return finished(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PracticeModelInitial value)? initial,
    TResult? Function(PracticeModelLoading value)? loading,
    TResult? Function(PracticeModelError value)? error,
    TResult? Function(PracticeModelFinished value)? finished,
    TResult? Function(PracticeModelInProgress value)? inProgress,
  }) {
    return finished?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PracticeModelInitial value)? initial,
    TResult Function(PracticeModelLoading value)? loading,
    TResult Function(PracticeModelError value)? error,
    TResult Function(PracticeModelFinished value)? finished,
    TResult Function(PracticeModelInProgress value)? inProgress,
    required TResult orElse(),
  }) {
    if (finished != null) {
      return finished(this);
    }
    return orElse();
  }
}

abstract class PracticeModelFinished extends PracticeModel {
  const factory PracticeModelFinished(final List<Impression> allImpressions,
      {final bool? navigatedAway}) = _$PracticeModelFinished;
  const PracticeModelFinished._() : super._();

  List<Impression> get allImpressions;
  bool? get navigatedAway;
  @JsonKey(ignore: true)
  _$$PracticeModelFinishedCopyWith<_$PracticeModelFinished> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PracticeModelInProgressCopyWith<$Res> {
  factory _$$PracticeModelInProgressCopyWith(_$PracticeModelInProgress value,
          $Res Function(_$PracticeModelInProgress) then) =
      __$$PracticeModelInProgressCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {List<Impression> allImpressions,
      List<Impression> remainingImpressions,
      Impression currentImpression,
      bool revealed,
      bool speechPlayed,
      DateTime? nextStepTime,
      DateTime? currentStepStart,
      double? pausedPercentage});

  $ImpressionCopyWith<$Res> get currentImpression;
}

/// @nodoc
class __$$PracticeModelInProgressCopyWithImpl<$Res>
    extends _$PracticeModelCopyWithImpl<$Res, _$PracticeModelInProgress>
    implements _$$PracticeModelInProgressCopyWith<$Res> {
  __$$PracticeModelInProgressCopyWithImpl(_$PracticeModelInProgress _value,
      $Res Function(_$PracticeModelInProgress) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? allImpressions = null,
    Object? remainingImpressions = null,
    Object? currentImpression = null,
    Object? revealed = null,
    Object? speechPlayed = null,
    Object? nextStepTime = freezed,
    Object? currentStepStart = freezed,
    Object? pausedPercentage = freezed,
  }) {
    return _then(_$PracticeModelInProgress(
      null == allImpressions
          ? _value._allImpressions
          : allImpressions // ignore: cast_nullable_to_non_nullable
              as List<Impression>,
      null == remainingImpressions
          ? _value._remainingImpressions
          : remainingImpressions // ignore: cast_nullable_to_non_nullable
              as List<Impression>,
      null == currentImpression
          ? _value.currentImpression
          : currentImpression // ignore: cast_nullable_to_non_nullable
              as Impression,
      null == revealed
          ? _value.revealed
          : revealed // ignore: cast_nullable_to_non_nullable
              as bool,
      null == speechPlayed
          ? _value.speechPlayed
          : speechPlayed // ignore: cast_nullable_to_non_nullable
              as bool,
      nextStepTime: freezed == nextStepTime
          ? _value.nextStepTime
          : nextStepTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      currentStepStart: freezed == currentStepStart
          ? _value.currentStepStart
          : currentStepStart // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      pausedPercentage: freezed == pausedPercentage
          ? _value.pausedPercentage
          : pausedPercentage // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ImpressionCopyWith<$Res> get currentImpression {
    return $ImpressionCopyWith<$Res>(_value.currentImpression, (value) {
      return _then(_value.copyWith(currentImpression: value));
    });
  }
}

/// @nodoc

class _$PracticeModelInProgress extends PracticeModelInProgress {
  const _$PracticeModelInProgress(
      final List<Impression> allImpressions,
      final List<Impression> remainingImpressions,
      this.currentImpression,
      this.revealed,
      this.speechPlayed,
      {this.nextStepTime,
      this.currentStepStart,
      this.pausedPercentage})
      : _allImpressions = allImpressions,
        _remainingImpressions = remainingImpressions,
        super._();

  final List<Impression> _allImpressions;
  @override
  List<Impression> get allImpressions {
    if (_allImpressions is EqualUnmodifiableListView) return _allImpressions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_allImpressions);
  }

  final List<Impression> _remainingImpressions;
  @override
  List<Impression> get remainingImpressions {
    if (_remainingImpressions is EqualUnmodifiableListView)
      return _remainingImpressions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_remainingImpressions);
  }

  @override
  final Impression currentImpression;
  @override
  final bool revealed;
  @override
  final bool speechPlayed;
  @override
  final DateTime? nextStepTime;
  @override
  final DateTime? currentStepStart;
  @override
  final double? pausedPercentage;

  @override
  String toString() {
    return 'PracticeModel.inProgress(allImpressions: $allImpressions, remainingImpressions: $remainingImpressions, currentImpression: $currentImpression, revealed: $revealed, speechPlayed: $speechPlayed, nextStepTime: $nextStepTime, currentStepStart: $currentStepStart, pausedPercentage: $pausedPercentage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PracticeModelInProgress &&
            const DeepCollectionEquality()
                .equals(other._allImpressions, _allImpressions) &&
            const DeepCollectionEquality()
                .equals(other._remainingImpressions, _remainingImpressions) &&
            (identical(other.currentImpression, currentImpression) ||
                other.currentImpression == currentImpression) &&
            (identical(other.revealed, revealed) ||
                other.revealed == revealed) &&
            (identical(other.speechPlayed, speechPlayed) ||
                other.speechPlayed == speechPlayed) &&
            (identical(other.nextStepTime, nextStepTime) ||
                other.nextStepTime == nextStepTime) &&
            (identical(other.currentStepStart, currentStepStart) ||
                other.currentStepStart == currentStepStart) &&
            (identical(other.pausedPercentage, pausedPercentage) ||
                other.pausedPercentage == pausedPercentage));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_allImpressions),
      const DeepCollectionEquality().hash(_remainingImpressions),
      currentImpression,
      revealed,
      speechPlayed,
      nextStepTime,
      currentStepStart,
      pausedPercentage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PracticeModelInProgressCopyWith<_$PracticeModelInProgress> get copyWith =>
      __$$PracticeModelInProgressCopyWithImpl<_$PracticeModelInProgress>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String error) error,
    required TResult Function(
            List<Impression> allImpressions, bool? navigatedAway)
        finished,
    required TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)
        inProgress,
  }) {
    return inProgress(
        allImpressions,
        remainingImpressions,
        currentImpression,
        revealed,
        speechPlayed,
        nextStepTime,
        currentStepStart,
        pausedPercentage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String error)? error,
    TResult? Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult? Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
  }) {
    return inProgress?.call(
        allImpressions,
        remainingImpressions,
        currentImpression,
        revealed,
        speechPlayed,
        nextStepTime,
        currentStepStart,
        pausedPercentage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String error)? error,
    TResult Function(List<Impression> allImpressions, bool? navigatedAway)?
        finished,
    TResult Function(
            List<Impression> allImpressions,
            List<Impression> remainingImpressions,
            Impression currentImpression,
            bool revealed,
            bool speechPlayed,
            DateTime? nextStepTime,
            DateTime? currentStepStart,
            double? pausedPercentage)?
        inProgress,
    required TResult orElse(),
  }) {
    if (inProgress != null) {
      return inProgress(
          allImpressions,
          remainingImpressions,
          currentImpression,
          revealed,
          speechPlayed,
          nextStepTime,
          currentStepStart,
          pausedPercentage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PracticeModelInitial value) initial,
    required TResult Function(PracticeModelLoading value) loading,
    required TResult Function(PracticeModelError value) error,
    required TResult Function(PracticeModelFinished value) finished,
    required TResult Function(PracticeModelInProgress value) inProgress,
  }) {
    return inProgress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PracticeModelInitial value)? initial,
    TResult? Function(PracticeModelLoading value)? loading,
    TResult? Function(PracticeModelError value)? error,
    TResult? Function(PracticeModelFinished value)? finished,
    TResult? Function(PracticeModelInProgress value)? inProgress,
  }) {
    return inProgress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PracticeModelInitial value)? initial,
    TResult Function(PracticeModelLoading value)? loading,
    TResult Function(PracticeModelError value)? error,
    TResult Function(PracticeModelFinished value)? finished,
    TResult Function(PracticeModelInProgress value)? inProgress,
    required TResult orElse(),
  }) {
    if (inProgress != null) {
      return inProgress(this);
    }
    return orElse();
  }
}

abstract class PracticeModelInProgress extends PracticeModel {
  const factory PracticeModelInProgress(
      final List<Impression> allImpressions,
      final List<Impression> remainingImpressions,
      final Impression currentImpression,
      final bool revealed,
      final bool speechPlayed,
      {final DateTime? nextStepTime,
      final DateTime? currentStepStart,
      final double? pausedPercentage}) = _$PracticeModelInProgress;
  const PracticeModelInProgress._() : super._();

  List<Impression> get allImpressions;
  List<Impression> get remainingImpressions;
  Impression get currentImpression;
  bool get revealed;
  bool get speechPlayed;
  DateTime? get nextStepTime;
  DateTime? get currentStepStart;
  double? get pausedPercentage;
  @JsonKey(ignore: true)
  _$$PracticeModelInProgressCopyWith<_$PracticeModelInProgress> get copyWith =>
      throw _privateConstructorUsedError;
}
